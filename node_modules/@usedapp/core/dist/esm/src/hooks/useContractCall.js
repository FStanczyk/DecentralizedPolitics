import { useMemo } from 'react';
import { useChainCalls } from './useChainCalls';
import { useChainId } from './useChainId';
function warnOnInvalidContractCall(call) {
    console.warn(`Invalid contract call: address=${call && call.address} method=${call && call.method} args=${call && call.args}`);
}
function encodeCallData(call, chainId) {
    if (!call) {
        return undefined;
    }
    if (!call.address || !call.method) {
        warnOnInvalidContractCall(call);
        return undefined;
    }
    try {
        return { address: call.address, data: call.abi.encodeFunctionData(call.method, call.args), chainId };
    }
    catch (_a) {
        warnOnInvalidContractCall(call);
        return undefined;
    }
}
/**
 * @public
 * @deprecated Use {@link useCalls} instead.
 */
export function useContractCall(call, queryParams = {}) {
    return useContractCalls([call], queryParams)[0];
}
/**
 * @public
 * @deprecated Use {@link useCall} instead.
 */
export function useContractCalls(calls, queryParams = {}) {
    const chainId = useChainId({ queryParams });
    const rawCalls = useMemo(() => calls.map((call) => (chainId !== undefined ? encodeCallData(call, chainId) : undefined)), [
        JSON.stringify(calls.map((call) => { var _a; return call && { address: (_a = call.address) === null || _a === void 0 ? void 0 : _a.toLowerCase(), method: call.method, args: call.args }; })),
        chainId,
    ]);
    const results = useChainCalls(rawCalls);
    return useMemo(() => results.map((result, idx) => {
        const call = calls[idx];
        if (result === '0x') {
            warnOnInvalidContractCall(call);
            return undefined;
        }
        return call && result ? call.abi.decodeFunctionResult(call.method, result) : undefined;
    }), [JSON.stringify(results)]);
}
//# sourceMappingURL=useContractCall.js.map