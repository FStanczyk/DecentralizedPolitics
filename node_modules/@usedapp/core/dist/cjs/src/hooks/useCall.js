"use strict";
exports.__esModule = true;
exports.useCalls = exports.useCall = void 0;
var react_1 = require("react");
var useRawCalls_1 = require("./useRawCalls");
var helpers_1 = require("../helpers");
var useChainId_1 = require("./useChainId");
/**
 * Makes a call to a specific method of a specific contract and returns the value or an error if present.
 * The hook will cause the component to refresh when a new block is mined and the return value changes.
 * A syntax sugar for useRawCall that uses ABI, function name, and arguments instead of raw data.
 * If typechain contract is used in call parameter then method name and arguments will be type checked.
 * Result will be typed as well.
 *
 * @param call a single call to a contract , also see {@link Call}
 * @returns The hook returns {@link CallResult} type.
 *          That is: undefined when call didn't return yet or a object { value | error } if it did,
 *          value: any[] | undefined - array of results or undefined if error occurred,
 *          error: Error | undefined - encountered error or undefined if call was successful.
 */
function useCall(call, queryParams) {
    if (queryParams === void 0) { queryParams = {}; }
    return useCalls([call], queryParams)[0];
}
exports.useCall = useCall;
/**
 * Makes calls to specific methods of specific contracts and returns values or an error if present.
 * The hook will cause the component to refresh when a new block is mined and the return values change.
 * A syntax sugar for useRawCalls that uses ABI, function name, and arguments instead of raw data.
 * @param calls a list of contract calls , also see {@link Call}.
 * @param queryParams see {@link QueryParams}.
 * @returns a list of results (see {@link CallResult} in {@link useCall} above).
 */
function useCalls(calls, queryParams) {
    if (queryParams === void 0) { queryParams = {}; }
    var chainId = (0, useChainId_1.useChainId)({ queryParams: queryParams });
    var isStatic = queryParams.isStatic;
    var rawCalls = (0, react_1.useMemo)(function () { return calls.map(function (call) { return (chainId !== undefined ? (0, helpers_1.encodeCallData)(call, chainId, isStatic) : undefined); }); }, [
        JSON.stringify(calls.map(function (call) { return call && { address: call.contract.address.toLowerCase(), method: call.method, args: call.args }; })),
        chainId,
    ]);
    var results = (0, useRawCalls_1.useRawCalls)(rawCalls);
    return (0, react_1.useMemo)(function () { return results.map(function (result, idx) { return (0, helpers_1.decodeCallResult)(calls[idx], result); }); }, [results]);
}
exports.useCalls = useCalls;
//# sourceMappingURL=useCall.js.map