"use strict";
exports.__esModule = true;
exports.MultiChainStateProvider = void 0;
var jsx_runtime_1 = require("react/jsx-runtime");
var react_1 = require("react");
var hooks_1 = require("../../../hooks");
var context_1 = require("./context");
var __1 = require("../../..");
var network_1 = require("../../network");
var blockNumbers_1 = require("../../blockNumber/blockNumbers");
var fromEntries_1 = require("../../../helpers/fromEntries");
var performMulticall_1 = require("../common/performMulticall");
var common_1 = require("../common");
var helpers_1 = require("../../../helpers");
var useDevtoolsReporting_1 = require("../common/useDevtoolsReporting");
var useChainId_1 = require("../../../hooks/useChainId");
function composeChainState(networks, state, multicallAddresses) {
    return (0, fromEntries_1.fromEntries)(Object.keys(networks).map(function (chainId) { return [
        Number(chainId),
        {
            value: state[Number(chainId)],
            multicallAddress: multicallAddresses[Number(chainId)]
        },
    ]; }));
}
/**
 * @internal Intended for internal use - use it on your own risk
 */
function MultiChainStateProvider(_a) {
    var children = _a.children, multicallAddresses = _a.multicallAddresses;
    var multicallVersion = (0, __1.useConfig)().multicallVersion;
    var networks = (0, network_1.useReadonlyNetworks)();
    var blockNumbers = (0, blockNumbers_1.useBlockNumbers)();
    var reportError = (0, __1.useNetwork)().reportError;
    var _b = (0, react_1.useReducer)(common_1.callsReducer, []), calls = _b[0], dispatchCalls = _b[1];
    var _c = (0, react_1.useReducer)(common_1.chainStateReducer, {}), state = _c[0], dispatchState = _c[1];
    var multicall = multicallVersion === 1 ? __1.multicall : __1.multicall2;
    var _d = (0, hooks_1.useDebouncePair)(calls, networks, 50), debouncedCalls = _d[0], debouncedNetworks = _d[1];
    var uniqueCalls = (0, react_1.useMemo)(function () { return (0, helpers_1.getUniqueActiveCalls)(debouncedCalls); }, [debouncedCalls]);
    // used for deep equality in hook dependencies
    var uniqueCallsJSON = JSON.stringify(debouncedCalls);
    var chainId = (0, useChainId_1.useChainId)();
    (0, useDevtoolsReporting_1.useDevtoolsReporting)(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);
    function multicallForChain(chainId, provider) {
        var blockNumber = blockNumbers[chainId];
        var multicallAddress = multicallAddresses[chainId];
        if (!provider || !blockNumber) {
            return;
        }
        if (!multicallAddress) {
            reportError(new Error("Missing multicall address for chain id ".concat(chainId)));
            return;
        }
        if (debouncedNetworks !== networks) {
            // Wait for debounce to catch up.
            return;
        }
        var callsOnThisChain = uniqueCalls.filter(function (call) { return call.chainId === chainId; });
        if (callsOnThisChain.length === 0) {
            return;
        }
        (0, performMulticall_1.performMulticall)(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);
        dispatchCalls({ type: 'UPDATE_CALLS', calls: calls });
    }
    (0, react_1.useEffect)(function () {
        for (var _i = 0, _a = Object.entries(networks); _i < _a.length; _i++) {
            var _b = _a[_i], _chainId = _b[0], provider = _b[1];
            multicallForChain(Number(_chainId), provider);
        }
    }, [blockNumbers, networks, multicallAddresses, uniqueCallsJSON]);
    var chains = (0, react_1.useMemo)(function () { return composeChainState(networks, state, multicallAddresses); }, [
        state,
        multicallAddresses,
        networks,
    ]);
    var provided = { chains: chains, dispatchCalls: dispatchCalls };
    return (0, jsx_runtime_1.jsx)(context_1.MultiChainStatesContext.Provider, { value: provided, children: children });
}
exports.MultiChainStateProvider = MultiChainStateProvider;
//# sourceMappingURL=provider.js.map